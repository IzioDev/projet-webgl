{"id":"index.html","dependencies":[{"name":"./utils/webgl-debug.ts","dynamic":true,"resolved":"/home/izio/Documents/IUT/3D/project-base/src/utils/webgl-debug.ts","parent":"/home/izio/Documents/IUT/3D/project-base/src/index.html"},{"name":"./main.ts","dynamic":true,"resolved":"/home/izio/Documents/IUT/3D/project-base/src/main.ts","parent":"/home/izio/Documents/IUT/3D/project-base/src/index.html"},{"name":"_css_loader","parent":"/home/izio/Documents/IUT/3D/project-base/src/index.html","resolved":"/home/izio/Documents/IUT/3D/project-base/node_modules/parcel-bundler/src/builtins/css-loader.js"},{"name":"/home/izio/Documents/IUT/3D/project-base/package.json","includedInParent":true,"mtime":1583419162142}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Super Soccer: Infinity</title>\n\n    <style>html, body {\n            margin: 0;\n        }</style>\n</head>\n<body>\n    <script src=\"/1c6d8a2912d68d55ea474fa917cddd33.js\"></script>\n    <script id=\"background-vs\" type=\"x-shader/x-vertex\">#version 300 es\n    // *** le vertex shader ***\n    layout(location=0) in vec3 aVertexPosition; // la position du sommet\n    layout(location=1) in vec2 aVertexCoord; // sa coordonnee de texture\n\n    out vec2 vTextureCoord; // on souhaite rasteriser la coordonnee\n    void main(void) {\n        // projection de la position\n        gl_Position = vec4(aVertexPosition, 1.0);\n\n        // stockage de la coordonnee de texture\n        vTextureCoord = aVertexCoord;\n    }\n    </script>\n\n    <script id=\"background-fs\" type=\"x-shader/x-fragment\">#version 300 es\n    // *** le fragment shader ***\n    precision highp float; // precision des nombres flottant\n\n    uniform vec2 uOffset;\n    uniform float uAmplitude; // amplitude du bruit\n    uniform float uFrequency; // frequence du bruit\n    uniform float uPersistence; // persistence du bruit\n\n    in vec2 vTextureCoord; // recuperation de la coord rasterisee\n    out vec4 outColor;\n\n    vec2 hash22(vec2 p) {\n        vec2 q = vec2(dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3)));\n        return fract(sin(q)*43758.5453123)*2.-1.;\n    }\n\n    float gnoise(in vec2 x) {\n        vec2 p = floor(x);\n        vec2 f = fract(x);\n        vec2 m = f*f*(3.-2.*f);\n\n        return mix(\n        mix(dot(hash22(p+vec2(0.,0.)),f-vec2(0.,0.)),\n        dot(hash22(p+vec2(1.,0.)),f-vec2(1.,0.)),m.x),\n        mix(dot(hash22(p+vec2(0.,1.)),f-vec2(0.,1.)),\n        dot(hash22(p+vec2(1.,1.)),f-vec2(1.,1.)),m.x),m.y);\n    }\n\n    float fractalNoise(in vec2 p) {\n        const int nb = 5; // nb octave\n        float f = uFrequency; // frequency\n        float a = uAmplitude; // amplitude\n        float e = uPersistence; // persistence\n        float n = 0.0;\n        for(int i=0;i<nb;++i) {\n            n = n + a*gnoise(p*f);\n            f = 2.0*f;\n            a = a*e;\n        }\n        return n;\n    }\n\n    float computeHeight(in vec2 p) {\n        // vous pouvez modifier cette fonction comme vous\n        // le souhaitez pour fabriquer votre propre background\n        return fractalNoise(p)*0.5+0.5;\n    }\n\n    vec3 computeNormal(in vec2 p) {\n        float scale = 70.0;\n        float xp = computeHeight(p+vec2( 0.001,0.0));\n        float xm = computeHeight(p+vec2(-0.001,0.0));\n        float yp = computeHeight(p+vec2(0.0, 0.001));\n        float ym = computeHeight(p+vec2(0.0,-0.001));\n\n        float gx = 0.5*(xp-xm)*scale;\n        float gy = 0.5*(yp-ym)*scale;\n\n        vec3 v1 = normalize(vec3(1.0,0.0,gx));\n        vec3 v2 = normalize(vec3(0.0,1.0,gy));\n\n        return cross(v1,v2);\n    }\n\n    void main(void) {\n        // d�calage avec la variable uOffset\n        vec2 p = vTextureCoord*2.0-vec2(1.0)+uOffset;\n\n        float d = computeHeight(p); // profondeur au point p\n        vec3 n = computeNormal(p); // normale au point p\n\n        // affichage de la profondeur\n        outColor = vec4(d,d,d,1.0);\n\n        // affichage de la normale\n        //outColor = vec4(n,1.0);\n    }\n    </script>\n\n    <script id=\"model-vs\" type=\"x-shader/x-vertex\">#version 300 es\n    // *** le vertex shader ***\n    layout(location=0) in vec3 aVertexPosition;\n    layout(location=1) in vec3 aVertexNormal;\n\n    uniform mat4 uModelMatrix;\n    uniform mat4 uViewMatrix;\n    uniform mat4 uProjMatrix;\n\n    out vec3 vNormal;\n\n    void main(void) {\n        // projection de la position\n        gl_Position = uProjMatrix * uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);\n        vNormal = mat3(inverse(transpose(uViewMatrix * uModelMatrix)))*normalize(aVertexNormal);\n    }\n    </script>\n\n    <script id=\"model-fs\" type=\"x-shader/x-fragment\">#version 300 es\n    // *** le fragment shader ***\n    precision mediump float; // precision des nombres flottant\n\n    in vec3 vNormal;\n    out vec4 outColor;\n\n    uniform vec3 ukd;\n    uniform vec3 ul;\n\n    void main(void) {\n\n        // la couleur est attribuee au fragment courant\n        vec3 n = normalize(vNormal);\n\n        vec3 v = vec3(0.0,0.0,-1.0);\n        //  vec3 l = vec3(0.0,0.0,1.0);\n        vec3 l = normalize(ul);\n\n        vec3 r = reflect(l, n);\n        vec3 kd = ukd;\n        vec3 ks = vec3(1.0);\n\n        //exposant\n        float s = 1.0;\n\n        float diff = max(dot(l, n), 0.0);\n        float spec = pow(max(dot(r,v), 0.0), s);\n\n        outColor = vec4(kd * diff + ks * spec,1.);\n    }\n    </script>\n\n    <script id=\"splat-vs\" type=\"x-shader/x-vertex\">#version 300 es\n    // *** le vertex shader ***\n    layout(location=0) in vec3 aVertexPosition; // la position du sommet\n    layout(location=1) in vec2 aVertexCoord; // sa coordonnee de texture\n\n    // uniform représente une variable globale (même pour tous les sommets du maillage)\n    uniform vec3 uPosition; // position du vaisseau\n    out vec2 vTextureCoord; // on souhaite rasteriser la coordonnee\n\n    void main(void) {\n        // projection de la position\n        gl_Position = vec4(aVertexPosition.xy+uPosition.xy,uPosition.z, 1.0);\n\n        // stockage de la coordonnee de texture\n        vTextureCoord = aVertexCoord;\n    }\n    </script>\n\n    <script id=\"splat-fs\" type=\"x-shader/x-fragment\">#version 300 es\n    // *** le fragment shader ***\n    precision highp float; // precision des nombres flottant\n\n    uniform vec3 maCouleur;\n    uniform sampler2D uTex;\n\n    in vec2 vTextureCoord; // recuperation de la coord rasterisee\n    out vec4 outColor;\n\n    void main(void) {\n        float alpha = 1.-smoothstep(0.2,0.25,distance(vec2(.5),vTextureCoord));\n\n        // TEST: affichae d'un point avec la couleur donn�e en param�tre\n        //outColor = vec4(alpha*maCouleur,alpha);\n\n        // TEST: affichage d'une texture donn�e en param�tre\n        outColor = texture(uTex,vTextureCoord);\n    }\n    </script>\n    <canvas id=\"super-soccer-canvas\" style=\"border: none;\" width=\"800\" height=\"800\">\n    </canvas>\n    <script src=\"/6427dc610ec40c788cba04a9c39d6dcf.js\"></script>\n</body>\n</html>\n"},"sourceMaps":null,"error":null,"hash":"038eddfebfe7163076d20d733d41d3ab","cacheData":{"env":{}}}